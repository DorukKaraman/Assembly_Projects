ORG 0
;I HAVE EDDITED THE LOOKUP TABLE OF KEYBOARD TO HAVE +,-,X,/ INSTEAD OF A,B,C,D
BACKTO505:
	ACALL CONFIGURE_LCD
KEYBOARD_LOOP:
	ACALL KEYBOARD
	MOV R1, A ;R1 HAS THE LEFTMOST DIGIT OF N1
	ACALL SEND_DATA
	ACALL KEYBOARD
	MOV R2, A ;R2 HAS THE RIGHTMOST DIGIT OF N1
	ACALL SEND_DATA
	ACALL KEYBOARD
	MOV R0, A ;R0 HAS EQUATION SYMBOL
	ACALL SEND_DATA
	ACALL KEYBOARD
	MOV R3, A ;R3 HAS THE LEFTMOST DIGIT OF N2
	ACALL SEND_DATA
	ACALL KEYBOARD
	MOV R4, A ;R4 HAS THE RIGHTMOST DIGIT OF N2
	ACALL SEND_DATA
ASCIITOHEX:
	;THE NUMBERS ARE AS ASCII SO I NEED TO CONVERT THEM TO HEXA (INPUT 1 IS 31 HEXA BUT I WANT IT TO BE 1)
	MOV B,#30
	MOV A, R1
	SUBB A, B
	MOV R1, A
	MOV B,#30
	MOV A, R2
	SUBB A, B
	MOV R2, A
	MOV B,#30
	MOV A, R3
	SUBB A, B
	MOV R3, A
	MOV B,#30
	MOV A, R4
	SUBB A, B
	MOV R4, A
OPERATION_SELECTION:
	MOV A,R0 ;A HAS THE VALUE OF EQUATION SYMBOL
	CJNE A,#'+', ADDOP
	CJNE A,#'-', SUBOP
	CJNE A,#'*', MULOP
	CJNE A,#'/', DIVOP
ADDOP:
	MOV A, R2 ;A HAS RIGHTMOST DIGIT OF N1
	MOV B, R4 ;B HAS RIGHTMOST DIGIT OF N2
	ADD A, B
	MOV R7, A ;R7 HAS THE SUM OF RIGHTMOST DIGITS
	MOV A,R1
	MOV B,R3
	ADDC A,B
	MOV R6, A
	MOV A, #0
	ADDC A,#0
	MOV R5,A
	MOV A, R5
	JNB A, ADD2DIG ;CHECKING IF THE LEFTMOST DIGIT IS ZERO
	ACALL SEND_DATA
	MOV A, R6
	ACALL SEND_DATA
	MOV A, R7
	ACALL SEND_DATA
ADD2DIG: ;IF IT IS ZERO DON'T PRINT THE LEFTMOST DIGIT
	MOV A, R6
	JNB A, ADD1DIG ;CHECKING IF THE LEFTMOST DIGIT OF THE 2 DIGIT NUMBER IS ZERO
	ACALL SEND_DATA
	MOV A, R7
	ACALL SEND_DATA
ADD1DIG: ;IF IT IS ZERO JUST PRINT THE RIGHTMOST DIGIT
	MOV A, R7
	ACALL SEND_DATA
SUBOP: ;RAN OUT OF TIME, WORKS ONLY WHEN RIGHTMOST N1> RIGHTMOST N2
	MOV A, R2 ;A HAS RIGHTMOST DIGIT OF N1
	MOV B, R4 ;B HAS RIGHTMOST DIGIT OF N2
	SUBB A, B
	MOV R7, A
	MOV A, R1
	MOV B, R3
	SUBB A, B
	MOV R6, A
	MOV R5, #0 ;AS YOU CANNOT GET 3 DIGIT NUMBER IN A SUBTRACTION OF 2 2DIGIT NUMBERS
	MOV A, R5
	JNB A, SUB2DIG ;CHECKING IF THE LEFTMOST DIGIT IS ZERO
	ACALL SEND_DATA
	MOV A, R6
	ACALL SEND_DATA
	MOV A, R7
	ACALL SEND_DATA
SUB2DIG: ;IF IT IS ZERO DON'T PRINT THE LEFTMOST DIGIT
	MOV A, R6
	JNB A, SUB1DIG ;CHECKING IF THE LEFTMOST DIGIT OF THE 2 DIGIT NUMBER IS ZERO
	ACALL SEND_DATA
	MOV A, R7
	ACALL SEND_DATA
SUB1DIG: ;IF IT IS ZERO JUST PRINT THE RIGHTMOST DIGIT
	MOV A, R7
	ACALL SEND_DATA
MULOP:
	MOV A, R2
	MOV B, R4
	MUL AB
	MOV R7, A ;R7 (RIGHTMOST DIGIT) IS COMPLETE
	MOV R6, B ;CARRY IS AT R6
	MOV A, R1
	MOV B, R4
	MUL AB
	ADD A, R6
	MOV R6, A
	MOV R5, B
	MOV A,R2
	MOV B,R3
	MUL AB
	ADD A,R6
	MOV R6,A
	MOV A,B
	ADD A,R7
	MOV R7,A
	MOV A,R1
	MOV B,R3
	MUL AB
	ADD A,R7
	MOV R7,A
	MOV A, R5
	JNB A, MUL2DIG ;CHECKING IF THE LEFTMOST DIGIT IS ZERO
	ACALL SEND_DATA
	MOV A, R6
	ACALL SEND_DATA
	MOV A, R7
	ACALL SEND_DATA
MUL2DIG: ;IF IT IS ZERO DON'T PRINT THE LEFTMOST DIGIT
	MOV A, R6
	JNB A, MUL1DIG ;CHECKING IF THE LEFTMOST DIGIT OF THE 2 DIGIT NUMBER IS ZERO
	ACALL SEND_DATA
	MOV A, R7
	ACALL SEND_DATA
MUL1DIG: ;IF IT IS ZERO JUST PRINT THE RIGHTMOST DIGIT
	MOV A, R7
	ACALL SEND_DATA
DIVOP:
	MOV A, R1 ;A HAS leftMOST DIGIT OF N1
	MOV B, R3 ;B HAS LEFTMOST DIGIT OF N2
	DIV AB
	MOV R5,A
	MOV A, #10
	MUL AB
	MOV B, R2
	ADD A, B
	MOV B, R3
	DIV AB
	MOV R6,A
	MOV A, R5
	JNB A, DIV2DIG ;CHECKING IF THE LEFTMOST DIGIT IS ZERO
	ACALL SEND_DATA
	MOV A, R6
	ACALL SEND_DATA
	MOV A, R7
	ACALL SEND_DATA
DIV2DIG: ;IF IT IS ZERO DON'T PRINT THE LEFTMOST DIGIT
	MOV A, R6
	JNB A, DIV1DIG ;CHECKING IF THE LEFTMOST DIGIT OF THE 2 DIGIT NUMBER IS ZERO
	ACALL SEND_DATA
	MOV A, R7
	ACALL SEND_DATA
DIV1DIG: ;IF IT IS ZERO JUST PRINT THE RIGHTMOST DIGIT
	MOV A, R7
	ACALL SEND_DATA
	ACALL KEYBOARD
	SJMP BACKTO505
;MY CODE ENDS HERE
CONFIGURE_LCD:	;THIS SUBROUTINE SENDS THE INITIALIZATION COMMANDS TO THE LCD
	mov a,#38H	;TWO LINES, 5X7 MATRIX
	acall SEND_COMMAND
	mov a,#0FH	;DISPLAY ON, CURSOR BLINKING
	acall SEND_COMMAND
	mov a,#06H	;INCREMENT CURSOR (SHIFT CURSOR TO RIGHT)
	acall SEND_COMMAND
	mov a,#01H	;CLEAR DISPLAY SCREEN
	acall SEND_COMMAND
	mov a,#80H	;FORCE CURSOR TO BEGINNING OF THE FIRST LINE
	acall SEND_COMMAND
	ret
SEND_COMMAND:
	mov p1,a		;THE COMMAND IS STORED IN A, SEND IT TO LCD
	clr p3.5		;RS=0 BEFORE SENDING COMMAND
	clr p3.6		;R/W=0 TO WRITE
	setb p3.7	;SEND A HIGH TO LOW SIGNAL TO ENABLE PIN
	acall DELAY
	clr p3.7
	ret
SEND_DATA:
	mov p1,a		;SEND THE DATA STORED IN A TO LCD
	setb p3.5	;RS=1 BEFORE SENDING DATA
	clr p3.6		;R/W=0 TO WRITE
	setb p3.7	;SEND A HIGH TO LOW SIGNAL TO ENABLE PIN
	acall DELAY
	clr p3.7
	ret
DELAY:
	push 0
	push 1
	mov r0,#50
DELAY_OUTER_LOOP:
	mov r1,#255
	djnz r1,$
	djnz r0,DELAY_OUTER_LOOP
	pop 1
	pop 0
	ret
KEYBOARD: ;takes the key pressed from the keyboard and puts it to A
	mov	P0, #0ffh	;makes P0 input
K1:
	mov	P2, #0	;ground all rows
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, K1
K2:
	acall	DELAY
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, KB_OVER
	sjmp	K2
KB_OVER:
	acall DELAY
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, KB_OVER1
	sjmp	K2
KB_OVER1:
	mov	P2, #11111110B
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, ROW_0
	mov	P2, #11111101B
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, ROW_1
	mov	P2, #11111011B
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, ROW_2
	mov	P2, #11110111B
	mov	A, P0
	anl	A, #00001111B
	cjne	A, #00001111B, ROW_3
	ljmp	K2
ROW_0:
	mov	DPTR, #KCODE0
	sjmp	KB_FIND
ROW_1:
	mov	DPTR, #KCODE1
	sjmp	KB_FIND
ROW_2:
	mov	DPTR, #KCODE2
	sjmp	KB_FIND
ROW_3:
	mov	DPTR, #KCODE3
KB_FIND:
	rrc	A
	jnc	KB_FIND
	inc	DPL
	inc	DPL
	inc	DPL
	inc	DPL
	movc	A, @A+DPTR
	mov P2, #0ffh
	ret
KCODE0:
	DB	'1', '2', '3', '+'
KCODE1:
	DB	'4', '5', '6', '-'
KCODE2:
	DB	'7', '8', '9', '*'
KCODE3:
	DB	'E', '0', '#', '/'